{"version":3,"sources":["../src/AnimatorCreator.js"],"names":["treeUtility","TreeUtility","AnimatorCreator","animationOptions","_treeNormalizer","TreeNormalizer","_assertAnimationOptions","_convertAnimationsToTimelineOptions","_sortTimelineOptions","_createAnimators","Array","isArray","Error","timelineOptions","map","animationOption","TimelineOption","sort","a","b","startAt","animators","options","points","from","controls","to","point","cursor","Cursor","node","values","parse","normalize","hasUnresolvedError","fromNode","allStructuresAreEqual","every","areTreeStructuresEqual","JSON","stringify","ValuesNodeAnimator"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,WAAW,GAAG,IAAIC,oBAAJ,EAApB;;IAEqBC,e;;;AACnB,2BAAYC,gBAAZ,EAA8B;AAAA;;AAC5B,SAAKA,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,eAAL,GAAuB,IAAIC,uBAAJ,EAAvB;;AAEA,SAAKC,uBAAL;;AACA,SAAKC,mCAAL;;AACA,SAAKC,oBAAL;;AACA,SAAKC,gBAAL;AACD;;;;8CAEyB;AACxB,UAAI,CAACC,KAAK,CAACC,OAAN,CAAc,KAAKR,gBAAnB,CAAL,EAA2C;AACzC,cAAM,IAAIS,KAAJ,CAAU,qCAAV,CAAN;AACD;AACF;;;0DAEqC;AACpC,WAAKC,eAAL,GAAuB,KAAKV,gBAAL,CAAsBW,GAAtB,CACrB,UAAAC,eAAe;AAAA,eAAI,IAAIC,uBAAJ,CAAmBD,eAAnB,CAAJ;AAAA,OADM,CAAvB;AAGD;;;2CAEsB;AACrB,WAAKF,eAAL,CAAqBI,IAArB,CAA0B,UAACC,CAAD,EAAIC,CAAJ,EAAU;AAClC,eAAOD,CAAC,CAACE,OAAF,GAAYD,CAAC,CAACC,OAArB;AACD,OAFD;AAGD;;;uCAEkB;AAAA;;AACjB,WAAKC,SAAL,GAAiB,KAAKR,eAAL,CAAqBC,GAArB,CAAyB,UAAAQ,OAAO,EAAI;AACnD,YAAIC,MAAM,IAAID,OAAO,CAACE,IAAZ,4BAAqBF,OAAO,CAACG,QAA7B,IAAuCH,OAAO,CAACI,EAA/C,EAAV;AACA,YAAID,QAAJ;AAEAA,QAAAA,QAAQ,GAAGF,MAAM,CAACT,GAAP,CAAW,UAAAa,KAAK,EAAI;AAC7B,cAAMC,MAAM,GAAG,IAAIC,4BAAJ,CAAWF,KAAX,CAAf;;AACA,cAAMG,IAAI,GAAGC,gBAAOC,KAAP,CAAaJ,MAAb,CAAb;;AACA,UAAA,KAAI,CAACxB,eAAL,CAAqB6B,SAArB,CAA+BH,IAA/B;;AAEA,cAAIF,MAAM,CAACM,kBAAP,EAAJ,EAAiC;AAC/B,kBAAM,IAAItB,KAAJ,4CACgCU,OAAO,CAACG,QADxC,EAAN;AAGD;;AAED,iBAAOK,IAAP;AACD,SAZU,CAAX;AAcA,YAAMK,QAAQ,GAAGV,QAAQ,CAAC,CAAD,CAAzB;AACA,YAAMW,qBAAqB,GAAGX,QAAQ,CAACY,KAAT,CAAe,UAAAP,IAAI,EAAI;AACnD,iBAAO9B,WAAW,CAACsC,sBAAZ,CAAmCH,QAAnC,EAA6CL,IAA7C,CAAP;AACD,SAF6B,CAA9B;;AAIA,YAAI,CAACM,qBAAL,EAA4B;AAC1B,gBAAM,IAAIxB,KAAJ,0FAC8E2B,IAAI,CAACC,SAAL,CAChFlB,OAAO,CAACE,IADwE,CAD9E,kBAGKe,IAAI,CAACC,SAAL,CAAelB,OAAO,CAACI,EAAvB,CAHL,yBAG8Ca,IAAI,CAACC,SAAL,CAChDlB,OAAO,CAACG,QADwC,CAH9C,EAAN;AAOD;;AAED,eAAO,IAAIgB,2BAAJ,mBACFnB,OADE;AAELG,UAAAA,QAAQ,EAARA;AAFK,WAAP;AAID,OArCgB,CAAjB;AAsCD;;;mCAEc;AACb,aAAO,KAAKJ,SAAZ;AACD","sourcesContent":["import ValuesNodeAnimator from \"./animators/ValuesNodeAnimator.js\";\nimport values from \"./patterns/values.js\";\nimport { Cursor } from \"clarity-pattern-parser\";\nimport TimelineOption from \"./TimelineOption.js\";\nimport TreeNormalizer from \"./TreeNormalizer.js\";\nimport TreeUtility from \"./TreeUtility.js\";\n\nconst treeUtility = new TreeUtility();\n\nexport default class AnimatorCreator {\n  constructor(animationOptions) {\n    this.animationOptions = animationOptions;\n    this._treeNormalizer = new TreeNormalizer();\n    \n    this._assertAnimationOptions();\n    this._convertAnimationsToTimelineOptions();\n    this._sortTimelineOptions();\n    this._createAnimators();\n  }\n\n  _assertAnimationOptions() {\n    if (!Array.isArray(this.animationOptions)) {\n      throw new Error(\"Expected animations to be an array.\");\n    }\n  }\n\n  _convertAnimationsToTimelineOptions() {\n    this.timelineOptions = this.animationOptions.map(\n      animationOption => new TimelineOption(animationOption)\n    );\n  }\n\n  _sortTimelineOptions() {\n    this.timelineOptions.sort((a, b) => {\n      return a.startAt - b.startAt;\n    });\n  }\n\n  _createAnimators() {\n    this.animators = this.timelineOptions.map(options => {\n      let points = [options.from, ...options.controls, options.to];\n      let controls;\n\n      controls = points.map(point => {\n        const cursor = new Cursor(point);\n        const node = values.parse(cursor);\n        this._treeNormalizer.normalize(node);\n\n        if (cursor.hasUnresolvedError()) {\n          throw new Error(\n            `Parse Error: could not parse css ${options.controls}`\n          );\n        }\n\n        return node;\n      });\n\n      const fromNode = controls[0];\n      const allStructuresAreEqual = controls.every(node => {\n        return treeUtility.areTreeStructuresEqual(fromNode, node);\n      });\n\n      if (!allStructuresAreEqual) {\n        throw new Error(\n          `Invalid Animation: The value types that are being animated do not match. From: ${JSON.stringify(\n            options.from\n          )}, To:${JSON.stringify(options.to)}, Controls: ${JSON.stringify(\n            options.controls\n          )}`\n        );\n      }\n\n      return new ValuesNodeAnimator({\n        ...options,\n        controls\n      });\n    });\n  }\n\n  getAnimators() {\n    return this.animators;\n  }\n}\n"],"file":"AnimatorCreator.js"}