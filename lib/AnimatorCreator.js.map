{"version":3,"sources":["../src/AnimatorCreator.js"],"names":["treeUtility","TreeUtility","treeNormalizer","TreeNormalizer","AnimatorCreator","animationOptions","_assertAnimationOptions","_convertAnimationsToAnimations","_sortAnimations","_createAnimators","Array","isArray","Error","timelineOptions","map","animationOption","Animation","sort","a","b","startAt","animators","options","points","from","controls","to","point","cursor","Cursor","node","cssValue","parse","normalize","hasUnresolvedError","fromNode","allStructuresAreEqual","every","areTreeStructuresEqual","JSON","stringify","CssValueNodeAnimator"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,WAAW,GAAG,IAAIC,oBAAJ,EAApB;AACA,IAAMC,cAAc,GAAG,IAAIC,uBAAJ,EAAvB;;IAEqBC,e;;;AACnB,2BAAYC,gBAAZ,EAA8B;AAAA;;AAC5B,SAAKA,gBAAL,GAAwBA,gBAAxB;;AAEA,SAAKC,uBAAL;;AACA,SAAKC,8BAAL;;AACA,SAAKC,eAAL;;AACA,SAAKC,gBAAL;AACD;;;;8CAEyB;AACxB,UAAI,CAACC,KAAK,CAACC,OAAN,CAAc,KAAKN,gBAAnB,CAAL,EAA2C;AACzC,cAAM,IAAIO,KAAJ,CAAU,qCAAV,CAAN;AACD;AACF;;;qDAEgC;AAC/B,WAAKC,eAAL,GAAuB,KAAKR,gBAAL,CAAsBS,GAAtB,CACrB,UAAAC,eAAe;AAAA,eAAI,IAAIC,kBAAJ,CAAcD,eAAd,CAAJ;AAAA,OADM,CAAvB;AAGD;;;sCAEiB;AAChB,WAAKF,eAAL,CAAqBI,IAArB,CAA0B,UAACC,CAAD,EAAIC,CAAJ,EAAU;AAClC,eAAOD,CAAC,CAACE,OAAF,GAAYD,CAAC,CAACC,OAArB;AACD,OAFD;AAGD;;;uCAEkB;AACjB,WAAKC,SAAL,GAAiB,KAAKR,eAAL,CAAqBC,GAArB,CAAyB,UAAAQ,OAAO,EAAI;AACnD,YAAIC,MAAM,IAAID,OAAO,CAACE,IAAZ,4BAAqBF,OAAO,CAACG,QAA7B,IAAuCH,OAAO,CAACI,EAA/C,EAAV;AACA,YAAID,QAAJ;AAEAA,QAAAA,QAAQ,GAAGF,MAAM,CAACT,GAAP,CAAW,UAAAa,KAAK,EAAI;AAC7B,cAAMC,MAAM,GAAG,IAAIC,4BAAJ,CAAWF,KAAX,CAAf;;AACA,cAAMG,IAAI,GAAGC,kBAASC,KAAT,CAAeJ,MAAf,CAAb;;AACA1B,UAAAA,cAAc,CAAC+B,SAAf,CAAyBH,IAAzB;;AAEA,cAAIF,MAAM,CAACM,kBAAP,EAAJ,EAAiC;AAC/B,kBAAM,IAAItB,KAAJ,4CACgCU,OAAO,CAACG,QADxC,EAAN;AAGD;;AAED,iBAAOK,IAAP;AACD,SAZU,CAAX;AAcA,YAAMK,QAAQ,GAAGV,QAAQ,CAAC,CAAD,CAAzB;AACA,YAAMW,qBAAqB,GAAGX,QAAQ,CAACY,KAAT,CAAe,UAAAP,IAAI,EAAI;AACnD,iBAAO9B,WAAW,CAACsC,sBAAZ,CAAmCH,QAAnC,EAA6CL,IAA7C,CAAP;AACD,SAF6B,CAA9B;;AAIA,YAAI,CAACM,qBAAL,EAA4B;AAC1B,gBAAM,IAAIxB,KAAJ,0FAC8E2B,IAAI,CAACC,SAAL,CAChFlB,OAAO,CAACE,IADwE,CAD9E,kBAGKe,IAAI,CAACC,SAAL,CAAelB,OAAO,CAACI,EAAvB,CAHL,yBAG8Ca,IAAI,CAACC,SAAL,CAChDlB,OAAO,CAACG,QADwC,CAH9C,EAAN;AAOD;;AAED,eAAO,IAAIgB,6BAAJ,mBACFnB,OADE;AAELG,UAAAA,QAAQ,EAARA;AAFK,WAAP;AAID,OArCgB,CAAjB;AAsCD;;;mCAEc;AACb,aAAO,KAAKJ,SAAZ;AACD","sourcesContent":["import CssValueNodeAnimator from \"./animators/CssValueNodeAnimator.js\";\nimport cssValue from \"./patterns/cssValue.js\";\nimport { Cursor } from \"clarity-pattern-parser\";\nimport Animation from \"./Animation.js\";\nimport TreeNormalizer from \"./TreeNormalizer.js\";\nimport TreeUtility from \"./TreeUtility.js\";\n\nconst treeUtility = new TreeUtility();\nconst treeNormalizer = new TreeNormalizer();\n\nexport default class AnimatorCreator {\n  constructor(animationOptions) {\n    this.animationOptions = animationOptions;\n\n    this._assertAnimationOptions();\n    this._convertAnimationsToAnimations();\n    this._sortAnimations();\n    this._createAnimators();\n  }\n\n  _assertAnimationOptions() {\n    if (!Array.isArray(this.animationOptions)) {\n      throw new Error(\"Expected animations to be an array.\");\n    }\n  }\n\n  _convertAnimationsToAnimations() {\n    this.timelineOptions = this.animationOptions.map(\n      animationOption => new Animation(animationOption)\n    );\n  }\n\n  _sortAnimations() {\n    this.timelineOptions.sort((a, b) => {\n      return a.startAt - b.startAt;\n    });\n  }\n\n  _createAnimators() {\n    this.animators = this.timelineOptions.map(options => {\n      let points = [options.from, ...options.controls, options.to];\n      let controls;\n\n      controls = points.map(point => {\n        const cursor = new Cursor(point);\n        const node = cssValue.parse(cursor);\n        treeNormalizer.normalize(node);\n\n        if (cursor.hasUnresolvedError()) {\n          throw new Error(\n            `Parse Error: could not parse css ${options.controls}`\n          );\n        }\n\n        return node;\n      });\n\n      const fromNode = controls[0];\n      const allStructuresAreEqual = controls.every(node => {\n        return treeUtility.areTreeStructuresEqual(fromNode, node);\n      });\n\n      if (!allStructuresAreEqual) {\n        throw new Error(\n          `Invalid Animation: The value types that are being animated do not match. From: ${JSON.stringify(\n            options.from\n          )}, To:${JSON.stringify(options.to)}, Controls: ${JSON.stringify(\n            options.controls\n          )}`\n        );\n      }\n\n      return new CssValueNodeAnimator({\n        ...options,\n        controls\n      });\n    });\n  }\n\n  getAnimators() {\n    return this.animators;\n  }\n}\n"],"file":"AnimatorCreator.js"}