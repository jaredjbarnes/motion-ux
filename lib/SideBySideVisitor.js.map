{"version":3,"sources":["../src/SideBySideVisitor.js"],"names":["emptyFn","treeUtility","TreeUtility","SideBySideVisitor","callback","setCallback","visitDown","bind","visitUp","nodes","Array","isArray","siblings","slice","node","areEqual","every","sibling","areTreeStructuresEqual","Error","walkUp","children","index","childNodes","map","length","walkDown"],"mappings":"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","sourcesContent":["import TreeUtility from \"./TreeUtility.js\";\n\nconst emptyFn = () => {};\nconst treeUtility = new TreeUtility();\n\nexport default class SideBySideVisitor {\n  constructor(callback) {\n    this.setCallback(callback);\n    this.visitDown = this.visitDown.bind(this);\n    this.visitUp = this.visitUp.bind(this);\n  }\n\n  visitUp(nodes) {\n    if (!Array.isArray(nodes)) {\n      return;\n    }\n\n    const siblings = nodes.slice(1);\n    const node = nodes[0];\n\n    const areEqual = siblings.every((sibling) =>\n      treeUtility.areTreeStructuresEqual(node, sibling)\n    );\n\n    if (!areEqual) {\n      throw new Error(\"The nodes structures need to be the same.\");\n    }\n\n    this.walkUp(nodes);\n  }\n\n  walkUp(nodes) {\n    if (!Array.isArray(nodes)) {\n      return;\n    }\n\n    const node = nodes[0];\n\n    if (Array.isArray(node.children)) {\n      for (let index = 0; index < node.children.length; index++) {\n        const childNodes = nodes.map((node) => {\n          return node.children[index];\n        });\n        this.walkUp(childNodes);\n      }\n    }\n\n    this.callback(...nodes);\n  }\n\n  visitDown(nodes) {\n    if (!Array.isArray(nodes)) {\n      return;\n    }\n\n    const siblings = nodes.slice(1);\n    const node = nodes[0];\n\n    const areEqual = siblings.every((sibling) =>\n      treeUtility.areTreeStructuresEqual(node, sibling)\n    );\n\n    if (!areEqual) {\n      throw new Error(\"The nodes structures need to be the same.\");\n    }\n\n    this.walkDown(nodes);\n  }\n\n  walkDown(nodes) {\n    if (!Array.isArray(nodes)) {\n      return;\n    }\n\n    this.callback(...nodes);\n\n    const node = nodes[0];\n    if (Array.isArray(node.children)) {\n      for (let index = 0; index < node.children.length; index++) {\n        const childNodes = nodes.map((node) => {\n          return node.children[index];\n        });\n        this.walkDown(childNodes);\n      }\n    }\n  }\n\n  setCallback(callback) {\n    if (typeof callback === \"function\") {\n      this.callback = callback;\n    } else {\n      this.callback = emptyFn;\n    }\n\n    this.callback = callback;\n  }\n}\n"],"file":"SideBySideVisitor.js"}